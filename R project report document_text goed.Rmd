---
title: "R Project Report"
author: "Rob Dregmans, Ivar Tjallingii, Martijn van Vliet, Ying Xu"
date: "November 9, 2018"
output: 
  html_document:
    toc: true # table of content true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/ivarnieuwepc/Documents/GitHub/data")
knitr::opts_chunk$set(comment=NA, fig.align = "center")
library(reshape)
library(reshape2)
library(dplyr)
library(tidyr)
library(plotly)
library(ineq)
library(ggplot2)
library(rjags)
library(MASS)
library(fitdistrplus)
library(PerformanceAnalytics)
library(knitr)    # For knitting document and include_graphics function
library(png)      # For grabbing the dimensions of png files

```

# Problem introduction

## Introduction to poverty

The world has committed itself to intensive targets for reducing poverty by 2030. The goal to reduce poverty and its related side effects are specified in Sustainable Development Goal (SDG) number one of the total seventeen SDG's set up in the 2030 Agenda for Sustainable Development. All seventeen goals and quantitative targets are meant to stimulate action over the next fifteen years in areas of critical importance for humanity and the planet [2]. 

## UN Targets

The negative effects of poverty are enormous. Poverty and related effects slow down development within whole countries. Certain groups are disproportionately represented and face additional constraints, such as limited access to resources and capabilities in escaping poverty. These include women, persons with disabilities, children, and indigenous peoples.

- Target 1: By 2030, eradicate extreme poverty for all people everywhere, currently measured as people living on less than $1.25 a day.

- Target 2: By 2030, reduce at least by half the proportion of men, women and children of all ages living in poverty in all its dimensions according to national definitions.

- Target 3: Implement nationally appropriate social protection systems and measures for all, including floors, and by 2030 achieve substantial coverage of the poor and the vulnerable.

- Target 4: By 2030, ensure that all men and women, in particular the poor and the vulnerable, have equal rights to economic resources.

-	Target 5: By 2030, build the resilience of the poor and those in vulnerable situations.

## The role of data in battling poverty

To mobilize resources to overcome inequalities between developed and developing countries data is needed. Data is widely used within decision-making and forms the raw material for accountability of policies. Today, in the private sector, analysis of big data is common for example with consumer profiling and personalized services. Similar techniques are being adopted to gain real-time insights into people’s wellbeing and to target aid interventions to vulnerable groups [2]. Sources of data, if applied responsibly, can enable more evidence-based decision-making, hereby contributing to making progress on the Sustainable Development Goals (SDGs) [1].

This is where a problem lies for analyzing the poverty problem. Within the World Development Indicators, a lot of data is missing on various indicators on poverty. According to the IEG, reaching the UN targets faces many obstacles, among one of them is the lack of regularly high-quality data. Of the 139 developing countries, 22 have no data for the past three decades, some 30 countries have not had a survey in the past decade, and 20 countries only have had one survey since 2000 [2]. 

What is even more striking, is that one third of these countries are in Sub-Saharan Africa, where poverty is most frequent. Furthermore, from the countries that are reporting new surveys, eighty percent are from middle-income economies or higher. Also, additions to the survey database have been declining in recent years and the number of surveys within five years of a given date are declining rapidly [2].

One of the problems of building and maintaining a usable poverty database are financial, it would cost around 30 million/year to continuously perform surveys in 77 lower income countries. But these costs are not the main problem. There is also an enormous lack of political will within the government to proper store poverty data. Political will covers a multitude of obstacles from a refusal to collect data to unwillingness to release data for analysis. Also, many surveys on poverty known to World Bank staff are not available to other analysts or even to the citizens of the country [3].

## Goal of this report

The success of the Sustainable Development Goals will be judged on what the data is telling us about their current state. For SDG 1, this will be mainly done in achieving the headline indicator of extreme poverty reduction, which is the share the population in a country living under the extreme poverty line of 1.90 a day. Without better poverty data, collected more frequently, and open to all, we will never know if that goal can be achieved. This can be done by collecting data, but it would take a lot of time to gather all this data and process it. Therefore, the main goal of this report is constructing a predictive model on basis of indicators that are related to poverty. We also try to get it an insight in the current state of poverty around the world to determine if our model predictions are accurate enough. 

## Research question

Our main research question is twofold. The main part is about constructing a model that predicts poverty for various countries around the world. Besides that, we try to explore the current state of poverty and the distribution of wealth around the world. 

*Our main research question is:*

What is the historic trend of poverty around the world since 1990 and can we predict the prevalence of extreme poverty within countries based on a predictive Bayesian model? 

*To answer this research, several sub questions are defined:*

•	Question 1: How did poverty in both absolute and multi-level poverty develop from 1990 – 2015 within regions and individual countries?
•	Question 2: How is wealth distributed within countries with the highest poverty headcount?
•	Question 3: Which indicators resemble good estimators for our poverty model?
•	Question 4: What are the parameters of our MCMC model to estimate the prevalence of poverty for countries with missing data?
•	Question 5: What is the accuracy of our predictive model?

## Methodology 

Within this report, we try to gain more insight behind the data of poverty around the world. First, we will clean and analyze the data by selecting the relevant indicators. By means of critical analysis and interpretation of figures and numbers, we try to find relations in the data to obtain useful indicators for our model. Also, relevant primary research on the topic of poverty will be included to compare our primary research findings.

R-studio is used as a tool to perform the data analysis within this research. R is widely used as a programming language for the visualization of data. It contains additional packages that are very powerful for data analysis and visualization purposes. Within our computations in R, several additional packages have been used. For example, Plotly has been used to make our detailed graphics. In Plotly visualizations are displayed in an efficient way and many possibilities to visualize the data are present. We also use several scripts provided within this course to estimate our model. 
	
# Data Understanding and Preparation

## Initial data collection

Our data comes from World Development Indicators database(http://data.worldbank.org/data-catalog/world-development-indicators). On the website we could download the data, WDIData.csv. We focus on one of the UN Sustainable Development Goals: No Poverty. Data of over 1440 indicators of more than 200 countries and regions from 1960 to 2015 are provided in the WDI dataset, but only some of them are relevant to what we want to discuss about.  

*We encounter two problems when we try to acquire the data.*

First, we narrow down the scope of indicators of the following fields that might be related to ‘No poverty’ goal, this includes the following indicators:

1. Poverty headcount and poverty gap:

-Poverty headcount ratio at national poverty lines (% of population)
-Rural poverty headcount ratio at national poverty lines (% of rural population)
-Urban poverty headcount ratio at national poverty lines (% of urban population)
-Poverty headcount ratio at $1.90 a day (2011 PPP) (% of population)
-Poverty headcount ratio at $3.20 a day (2011 PPP) (% of population)
-Poverty headcount ratio at $5.50 a day (2011 PPP) (% of population)
-Poverty gap at $1.90 a day (2011 PPP) (%)
-Poverty gap at $3.20 a day (2011 PPP) (%)
-Poverty gap at $5.50 a day (2011 PPP) (%)
-Poverty gap at national poverty lines (%)

2. Social welfare:

-Coverage of social safety net programs (% of population)
-Coverage of social insurance programs (% of population)

3. Indicators that we decide to use (life expectation, education and economy)



Secondly, we choose to start our analysis in a world level to have a first sight into the data, and then focus on some certain countries with data in relatively abnormal trend. 

Thirdly, we mostly use the data from 1990 to 2015. The number of people living in extreme poverty dropped by more than half between 1990 and 2015. We want to find out the exact trend of how poverty has changed in the word thought out that period. Furthermore, we try to quantify the correlation between poverty in certain countries and the social welfare system in those countries to have a basic knowledge on how effective the social programs are. 

Last, we want to predict the missing data on poverty with our regression model using predictors of life expectancy, education, and mortality of infants, and with the data we will get a fuller picture of how the poverty will be reduced in the future.

## Data Description and quality problem

We assume that indicators about social safety program, education, life expectation, mortality rate of infants are related to the poverty situation in countries. And we also make the hypothesis that social safety program, education and life expectation have negative correlation with poverty, while mortality rate of infants is positively related to poverty. These indicators include scales of both social science and economy so that we could investigate the properties of poverty with a broader scope. 
But in the indicators we choose, a lot of data is missing. We have two solutions on the missing data. The first solution is to drop off the data with missing part. The other way is to estimate the missing data with our regression model.


## Loading, choosing and merging the data

After we load the data and using the file encoding type as UTF-8, we make several changes to make the dataset neater. We drop off all the final blank columns which contain no data at all. 

```{r}
# Read the data in correctly
mydata_utf8 = read.table("WDI/WDIData.csv",sep=",",fileEncoding="UTF-8-BOM",header=TRUE)  

# drop off the final blank column
mydata = mydata_utf8[,1:62]

all_code = unique(mydata[,1:2])
all_var = unique(mydata[,3:4])

# use the right countries
#country_code = read.table("data/WDI/country_code.csv",sep=",",header=FALSE)  
# listing all our variables and group them by UN targets or characteristics
```

And then extract the list of countries and indicators concluded in the file by using function unique. Here we make a list of names of indicators that we are interested in, and group them according to the scopes they belong to. Then we merge them in to one single longer data frame and make a subset of the data between 1995 and 2015.

```{r}
Grouping_variables_population = list("SI.POV.NAGP","SP.RUR.TOTL.ZS","SP.POP.GROW","SP.POP.TOTL","SP.POP.TOTL.MA.IN","SP.POP.TOTL.FE.IN","SP.URB.TOTL.IN.ZS", "SI.POV.URHC", "SP.RUR.TOTL.ZS", "SI.POV.RUHC", "SI.POV.DDAY", "SP.POP.TOTL")

Predictor_variables = list("SP.DYN.LE00.IN","SE.XPD.TOTL.GD.ZS", "SE.XPD.TOTL.GD.ZS","SN.ITK.DEFC.ZS","SH.DYN.MORT")

Target_1_Headcount_Poverty_190_320_550 = list("SI.POV.DDAY","SI.POV.LMIC,SI.POV.UMIC","SI.POV.GAPS","SI.POV.LMIC.GP","SI.POV.UMIC.GP")

Target_2_National_Poverty_Lines_Indicator = list("SI.POV.NAHC","SI.POV.RUHC","SI.POV.URHC","SI.POV.NAGP","SI.POV.RUGP",
                                              "SI.POV.URGP")

Target_3_A_Social_insurance_programm = list("per_si_allsi.cov_pop_tot",
                                         "per_si_allsi.cov_q2_tot",
                                         "per_si_allsi.cov_q3_tot",
                                         "per_si_allsi.cov_q4_tot",
                                         "per_si_allsi.cov_q1_tot",
                                         "per_si_allsi.cov_q5_tot",
                                         "per_allsp.cov_pop_tot")

Target_3_B_Social_Safety_Net_programm = list("per_sa_allsa.cov_pop_tot",
                                          "per_sa_allsa.cov_q2_tot",
                                          "per_sa_allsa.cov_q3_tot",
                                          "per_sa_allsa.cov_q4_tot",
                                          "per_sa_allsa.cov_q1_tot",
                                          "per_sa_allsa.cov_q5_tot")

Target_3_C_Social_Safety_Net_programm = list("per_lm_alllm.cov_pop_tot",
                                          "per_lm_alllm.cov_q2_tot",
                                          "per_lm_alllm.cov_q3_tot",
                                          "per_lm_alllm.cov_q4_tot",
                                          "per_lm_alllm.cov_q1_tot",
                                          "per_lm_alllm.cov_q5_tot")

indicators_income_share = list("SI.DST.04TH.20","SI.DST.10TH.10","SI.DST.05TH.20","SI.DST.FRST.10",
                            "SI.DST.FRST.20","SI.DST.02ND.20","SI.DST.03RD.20")

indicators_economy = list("NY.GNP.PCAP.CD","NY.GNP.MKTP.CN","FP.CPI.TOTL.ZG","NY.GDP.DEFL.KD.ZG","NY.GDP.DEFL.KD.ZG.AD",
                       "TX.VAL.MRCH.CD.WT","TX.VAL.MRCH.WL.CD","TM.VAL.MRCH.CD.WT","TM.VAL.MRCH.WL.CD","SI.POV.GINI")

indicators_life_span = list("SH.DTH.IMRT","SP.DTH.INFR.ZS","SP.DTH.INFR.ZS","SP.DYN.TO65.FE.ZS","SP.DYN.TO65.MA.ZS",
                         "SP.DYN.IMRT.IN","SP.DYN.IMRT.FE.IN","SP.DYN.IMRT.MA.IN")

#putting all indicators names in one list to merge all lists with a loop, see below
List_of_indicators_list = list(Predictor_variables,indicators_life_span,indicators_economy,indicators_income_share, Target_3_C_Social_Safety_Net_programm,Target_3_B_Social_Safety_Net_programm,Target_3_A_Social_insurance_programm,Target_2_National_Poverty_Lines_Indicator,Target_1_Headcount_Poverty_190_320_550,Grouping_variables_population)

my_vars = list()
for (i in List_of_indicators_list ) {
  my_vars = append(my_vars,i)
}
my_vars_c = c(my_vars)
# subset the data 
indicator_data = subset(mydata,mydata$Indicator.Code %in% my_vars_c)
# subset the data - selected var with only 1990 - 2015
indicator_data_1990_2015 = indicator_data[,c(2:3,4:4,35:60)]


```

## Reshaping

But for purpose of easier use, we reshape the data into the format that in each row, there’s one value of an indicator in one country of one year, with the columns of country code, region, country name, indicator code, indicator name, year, and the value. This is also known as a wide to long format transformation. We delete the “X” in the name of years, for the potential usage of the scale of time in the temporal distribution in the following part in the report.

```{r}
colnames(indicator_data_1990_2015) <- sub("X", "", colnames(indicator_data_1990_2015))
our_indicator_data= melt(indicator_data_1990_2015,id=c("Indicator.Code","Indicator.Name","Country.Code"), value.name = "Year")
#setting up indicator data with country names from python @martijn
country_names = read.table("country_names.csv",sep = ",", header = TRUE)
country_wdi = country_names[,c(1:2,5:5)]

colnames(country_wdi) = c("Country.Code","Region","Region/Country Name")
our_indicator_data = merge(country_wdi,our_indicator_data,id = "Country.Code")
colnames(our_indicator_data)=c("Country.Code","Region","Country.Name","Indicator.Code","Indicator.Name","Year","Value")
```

And then we make a name list of the countries involved in the subset of indicators we choose. Also, we want to make some analysis on the level of region level, so we extract the 
name list of the regions as well.

```{r}
#Obtaining lists for information about regions and countries
all_region_and_country_codes=our_indicator_data[,1:3]
all_region_and_country_codes=unique(all_region_and_country_codes)
all_regions = subset(all_region_and_country_codes, all_region_and_country_codes$Region == "")
all_countries = subset(all_region_and_country_codes, all_region_and_country_codes$Region != "")

#did a work around because factor levels in R
general_regions = unique(all_countries['Region'])
region_list = c('Latin America & Caribbean','South Asia','Sub-Saharan Africa','Europe & Central Asia','Middle East & North Africa','East Asia & Pacific','North America')

#Subset to extract regions
regions_used = subset(all_regions, all_regions$'Region/Country Name' %in% region_list)
regions_used = regions_used[,-c(2)]
```

## Data preparation for further graphs drawing 

In this part we want to prepare the data for the bubble charts about poverty and life expectancy, which indicates the correlation between these two indicators. We calculate the Total population of people who live in poverty by multiple two indicators: all population in the country and the poverty headcount ratio at $1.90 a day. 

```{r}
#making bubble chart of poverty 3.10 and life expectancy
var_i = c("SH.DYN.MORT","SI.POV.DDAY","SP.POP.TOTL")

#subset the data with only the world and the two indicators above about population and people in poverty and life expectancy
bubble_chart_1 = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_i)
test <- subset(bubble_chart_1, select = c("Indicator.Code","Region", "Country.Name", "Country.Code", "Year", "Value"))
df_bubble = dcast(test,Country.Code + Country.Name + Region + Year ~ Indicator.Code, value.var ="Value")
df_bubble_2013 = df_bubble[which(df_bubble$Year == 2012),]
df_bubble_2013$SP.POP.TOTL = df_bubble_2013$SP.POP.TOTL/1000000
df_bubble_2013$SI.POV.DDAY = df_bubble_2013$SI.POV.DDAY/100
df_bubble_2013$TotalPopPov = df_bubble_2013$SI.POV.DDAY * df_bubble_2013$SP.POP.TOTL

colnames(df_bubble_2013) = c("Country.Code", "Country.Name","Region","Year","ChildMort", "Poverty","TotalPop","TotalPopPov")
```

In this chart we only want to discuss at the national level instead of at regional level, so we exclude all the regional data as well as any NA value. And then we fix the data to the format with two decimals.

```{r}
#omit NA's
df_bubble_2013_na = na.omit(df_bubble_2013)
#order to omit regions, only hold countries
df_bubble_2013_na = df_bubble_2013_na[order(df_bubble_2013_na$Region, df_bubble_2013_na$Country.Name),]
k = as.numeric(dim(df_bubble_2013_na))[1]
df_bubble_2013_na_se = df_bubble_2013_na[c(13:k),]
#fix values with to many decimals and poverty percentage value
df_bubble_2013_na_se$Poverty = df_bubble_2013_na_se$Poverty *100
df_bubble_2013_na_se$Poverty = round(df_bubble_2013_na_se$Poverty,2)
df_bubble_2013_na_se$TotalPop = round(df_bubble_2013_na_se$TotalPop,2)
df_bubble_2013_na_se$TotalPopPov = round(df_bubble_2013_na_se$TotalPopPov,2)
df_bubble_2013_na_se$ChildMort = round(df_bubble_2013_na_se$ChildMort,2)

#CODE FOR MAKING THE BUBBLE CHATY OF POVERTY AND LIFE EXPECTANCY
#making bubble chart of poverty 1.90 and life expectancy
var_i = c("SP.DYN.LE00.IN","SI.POV.DDAY","SP.POP.TOTL")

#subset the data with only the world and the two indicators above about population and people in poverty and life expectancy
graph_data = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_i)
test <- subset(graph_data, select = c("Indicator.Code","Region", "Country.Name", "Country.Code", "Year", "Value"))
df_bubble = dcast(test,Country.Code + Country.Name + Region + Year ~ Indicator.Code, value.var ="Value")
df_bubble_2013 = df_bubble[which(df_bubble$Year == 2012),]
df_bubble_2013$SP.POP.TOTL = df_bubble_2013$SP.POP.TOTL/1000000
df_bubble_2013$SI.POV.DDAY = df_bubble_2013$SI.POV.DDAY/100
df_bubble_2013$TotalPopPov = df_bubble_2013$SI.POV.DDAY * df_bubble_2013$SP.POP.TOTL

colnames(df_bubble_2013) = c("Country.Code", "Country.Name","Region","Year","Poverty","LifeExpec","TotalPop","TotalPopPov")

#omit NA
df_bubble_2013_na = na.omit(df_bubble_2013)
#order to omit regions only hold countries
df_bubble_2013_na = df_bubble_2013_na[order(df_bubble_2013_na$Region, df_bubble_2013_na$Country.Name),]
k = as.numeric(dim(df_bubble_2013_na))[1]
df_bubble_2013_na = df_bubble_2013_na[c(13:k),]
#fix values with to many decimals and poverty percentage value
df_bubble_2013_na$Poverty = df_bubble_2013_na$Poverty *100
df_bubble_2013_na$Poverty = round(df_bubble_2013_na$Poverty,2)
df_bubble_2013_na$TotalPop = round(df_bubble_2013_na$TotalPop,2)
df_bubble_2013_na$TotalPopPov = round(df_bubble_2013_na$TotalPopPov,2)
df_bubble_2013_na$LifeExpec = round(df_bubble_2013_na$LifeExpec,2)
df_bubble=merge(df_bubble_2013_na,df_bubble_2013_na_se,id= "Country.Code", all.x = T)
```

# Data exploration

Within chapter 3, we try to answer our research question by means of several sub questions, see section 1.2. This is mainly done by analyzing large datasets and trying to visualize this data by means of appropriate graphs. We try to gain more insight in the state of of poverty around the world.

Firstly, the current state of hunger in the world shall be analyzed by looking at the prevalence of poverty around the world, see section 3.1. Here we will discuss the problem of missing data in terms of estimating the poverty headcount within countries over a longer period. To answer the second research question, we will look at the distribution of wealth by analyzing GINI indexes and Lorenz curves, see section 3.2. For the third research question, we plot several bubble charts and consider correlation between variables in our data, see section 3.3.


## The state of poverty around the world
In this part we choose the indicators of Poverty headcount ratio at $1.90 a day and the total population in the country. We make subset of those indicators and again omit any NA values. Then we calculate the population living under absolute poverty and show it by line graphs.

```{r}
#FOR THE LINECHART ABOUT ABSOLUTE POVERTY
world = c("WLD")
var_i = c("SI.POV.DDAY", "SP.POP.TOTL")
#subset the data with only the world and the two indicators above about population and people in poverty in %
graph_absolute = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_i)
graph_absolute = subset(graph_absolute,graph_absolute$'Country.Code' %in% world)
graph_absolute = graph_absolute[,c(4:7)]
#split the indicator column into two columns
wide = dcast(graph_absolute,Year ~ Indicator.Code,  value.var = "Value")
#this is a workaround for getting for each year the value for the two indicators into the same row
#omit all na values
wide <- na.omit(wide)

#multiply the data to get the absolute number of people living in poverty
wide$absolute <- (wide$SI.POV.DDAY/100) * (wide$SP.POP.TOTL/(10^9))
wide$absolute = round(wide$absolute,3)

#add hover text
wide$hover = with(wide, paste( "Year:", Year ,
                               "<br> World population living in extreme poverty:",absolute,"B",
                               "<br> Share of global population:", SI.POV.DDAY,"%"))
```

The graph below shows the absolute number of people living in poverty (below 1.90$ a day) over the years 1980 till 2015. The graph is interactive, when you hover over it more information about the share of the total word population living in poverty becomes visible.

In the graph we see the absolute number of people living in poverty, which means they have only 1.90$ a day to spend. The data from this graph is acquired by multiplying the percentage of people living in poverty by the total population of that same country. All these numbers are summed and then displayed. We can see that the absolute number of people living in poverty is rapidly declining, but nevertheless way to high. Whereas in 1990 1898 million people were living in poverty, now in 2015 that number is 736 million. Note that this is the absolute number of people living in poverty and that the number is not corrected for the trend in population growth. So, in a more optimistic view, even since the world population has risen, the absolute number of people living in poverty is declining.
```{r}
#layout
a <- list(
  title = "Years",
  showticklabels = TRUE,
  gridwidth = 2,
  autotick = F, 
  dtick = 2,
  range = c(0,25),
  showline = T
)
b <- list(
  title = "Number of people living in poverty (below 1,90$ a day) (billions)",
  showticklabels = TRUE,
  gridwidth = 2,
  showline = T,
  range = c(0,2)
)
#plot the graph
plot_ly(wide, x = ~Year, y = ~absolute, text = ~hover ,type = 'scatter', mode = 'lines') %>% 
  layout(xaxis = a, yaxis = b, title = 'Global population living in extreme poverty 1990 - 2015')
```


### Distribution across regions

Here we want to show the poverty gap in different regions. After deleting the rows with only NA value but not any data, we melt it to change the dataset from wide format to long format. Then we draw a stacked line chart based on the subset of data.

```{r}
poverty_gap_data <- subset(mydata,mydata$Indicator.Code=="SI.POV.GAPS")
poverty_gap_data_1990 <- poverty_gap_data[,c(1:3,4:4, 35:60)]
# remove the 'X' in the columns
colnames(poverty_gap_data_1990) <- sub("X", "", colnames(poverty_gap_data_1990))
#remove the rows without any data
poverty_gap_withoutNA <- poverty_gap_data_1990[-which(rowSums(is.na(poverty_gap_data_1990))>24),]
#reshape the data for drawing graphs
poverty_melt = melt(poverty_gap_withoutNA, id=c("Indicator.Code","Country.Name","Indicator.Name","Country.Code"), value.name = "Year")
#stacked area graph
##poverty line $1.90, six regions in one graph
regions_melt <- subset(poverty_melt, Country.Name =="East Asia & Pacific" | Country.Name =="Europe & Central Asia"| Country.Name =="Latin America & Caribbean"| Country.Name =="Middle East & North Africa"| Country.Name =="South Asia"| Country.Name =="Sub-Saharan Africa")
```

Below, we provided an overview of recent poverty trends for the standard ISO-regions, as provided by the OECD. The figure provides regional estimates of poverty rates (i.e. the share of population in each region living below the International Poverty Line). The poverty gap corresponds to the International Poverty Line, at 1.90 int.$ in 2011 PPP prices.

In Sub-Saharan Africa and South Asia, the  number of people in extreme poverty has increased, but since 2010, the absolute number of people in extreme poverty is declining in all world regions.

```{r,fig.width=9}
gg <- ggplot(regions_melt, aes(x=as.numeric(as.character(variable)), y=value))
gg <- gg + geom_area(aes(fill=Country.Name))
#the color of the stacked area
gg = gg + scale_fill_brewer(palette="Greens", breaks=rev(levels(regions_melt$Country.Name)))
#label name
gg <- gg + labs(x="Year", y="Poverty ratio, share of total population per region",col="Regions")
#label of the legend
gg <- gg + guides(fill = guide_legend(title = "Region"))
#remove the background and grid
gg <- gg + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                              panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
gg

```

### Distribution across countries

In the world map we only use the data of populations people in poverty from 2010 to 2015. To deal with the missing data, we choose to use the mean value of 6 years and use it as representative value. By doing that we have more data of population relating to poverty, while keeping the data relatively accurate because we have a pool of data of the past 6 years.

``` {r}
knitr::opts_chunk$set(echo = TRUE)

#selecting data from wdi + average of 6 years 2010 - 2015
var_i = c("SI.POV.DDAY","SP.POP.TOTL")
year = c('2010','2011', '2012','2013','2014','2015')

#subset the data with only the world and the two indicators above about population and people in poverty
geo_map_average = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_i)
geo_map_average = subset(geo_map_average,geo_map_average$Year %in% year)
geo_map_average <- subset(geo_map_average, select = c("Indicator.Code","Country.Name", "Country.Code", "Year", "Value"))

#Calculate average over columns
df_mean_pov = dcast(geo_map_average,Country.Code + Country.Name + Indicator.Code ~ Year, value.var ="Value")
df_mean_pov['mean'] = rowMeans(df_mean_pov[,4:9],na.rm = T)
df_mean_pov = dcast(df_mean_pov,Country.Code + Country.Name  ~ Indicator.Code, value.var ="mean")
colnames(df_mean_pov) = c("Country.Code","Country.Name","MeanHeadCount","MeanPop")

#fix indicator values for plotting and calculate poverty population
df_mean_pov$MeanPop = df_mean_pov$MeanPop/1000000
df_mean_pov['MeanPovPop'] = df_mean_pov[,3]*(df_mean_pov[,4]/100)
df_mean_pov$MeanPop = round(df_mean_pov$MeanPop,2)
df_mean_pov$MeanHeadCount = round(df_mean_pov$MeanHeadCount,2)
df_mean_pov$MeanPovPop = round(df_mean_pov$MeanPovPop,2)
```

The world map is showing the prevalence of poverty displayed per country. What immediately attracts the eye are the big red spots in Africa, where the prevalence of poverty is the highest. However, there are also a lot of white spots, which represent missing data. To get a better idea of the real prevalence of poverty in Africa, we need to do something about that missing data.

```{r, layout="l-screen-inset", , fig.width=13, fig.height=8}

# light grey boundaries
l <- list(color = toRGB("grey"), width = 0.5)

df_mean_pov$hover <- with(df_mean_pov, paste
                                     ( "Year: 2015",'<br>',
                                       "Percentage under extreme poverty line:",MeanHeadCount,"%" ,'<br>',
                                       "Mean population living in extreme poverty:",MeanPovPop,"M",'<br>',
                                       "Total population:",MeanPop,"M",'<br>', 
                                       "Country:", Country.Name))

# specify map projection/options
g <- list(
  showframe = F,
  resolution = 5,
  showcoastlines = T,
  countrycolor = toRGB("grey"),
  coastlinecolor = toRGB("grey"),
  projection = list(type = 'Mercator'))

k <- plot_geo(df_mean_pov) %>%
  add_trace(z = ~MeanHeadCount,text = ~hover, color = ~MeanHeadCount, colors= 'Reds', 
            locations = ~Country.Code, 
            marker = list(line = l,color = 'rgb(255,255,255)')) %>%
  
  colorbar(title = 'Share of population') %>%
  layout(title = 'Prevalance of Extreme Poverty during 2010 - 2015 (below 1.90$ a day)',geo = g)
k
```


### Multi level poverty and distribution of wealth

The Multidimensional Poverty Index (MPI) published by the Oxford Poverty & Human Development Initiative (OPHI). The MPI is not aggregated at the country level, but at the individual level—it measures how one individual is deprived in different 'poverty' dimensions.

The MPI is constructed from ten indicators across three core dimensions: health, education and living standards. In the following map below, we plotted the share of MPI poor people country by country. The multidimensional poverty index not only uses regular economic indicators such as income, consumption and GINI data, but also non-economic indicators such as nutrition, electricity and schooling. 

We choose only the data related to multi-level poverty and we omit the last several columns without any data. Also, we make an information table of which occurs when we put out mouse on a country and shows more related information on the country, such as country name, multi poverty index and child school attendance.

```{r}
#Selecting MDI Data, drop last 3 columns with no values
MPIData = read.table("MPIData.csv",sep=";",header=TRUE)  
colnames(MPIData)[1] <- "CountryCode"
MPIData = MPIData[,1:20]

#Selecting MDI Data, drop last 3 columns with no values
MPIData2016 = read.table("MPIData2016.csv",sep=";",header=TRUE)  
colnames(MPIData2016)[1] <- "PublishYear"

# light grey boundaries
l <- list(color = toRGB("grey"), width = 0.5)

MPIData2016$hover <- with(MPIData2016, paste
                      ( "Year:", SurveyYear,
                            "<br> Country:", Country,
                            "<br> Share of the pop. in Multi Level Poverty: ", Headcount.ratio ,"%",
                            "<br> Multi Poverty Index:", MPI,
                            "<br> Child school attendace:", ChildSchoolAttendance, "%"))
```

Using the MPI to map poverty around the world, it provides us with a more clear picture of how prevalent poverty currently is around the globe. As we can see, this alternative metric shows that poverty is also particularly prevalent in sub-Saharan Africa, but also in India and Afghanistan. It is still a limitation that the MPI data relies heavenly on aggregated multi year data. So, it is not possible to track the progress of countries on their MPI for individual years, just like the wolrd map of the prevelance of poverty we plotted over the 5 years average. So, we are still looking for ways to get a better picture of the prevalence of poverty [8].


```{r, layout="l-screen-inset", , fig.width=13, fig.height=8}
                          
# specify map projection/options
g <- list(
  showframe = F,
  resolution = 5,
  showcoastlines = T,
  countrycolor = toRGB("grey"),
  coastlinecolor = toRGB("grey"),
  projection = list(type = 'Mercator') 
)

k <- plot_geo(MPIData2016) %>%
  add_trace(z = ~Headcount.ratio,text = ~hover, color = ~Headcount.ratio, colors = 'YlGnBu' ,
            locations = ~CountryCode, 
            marker = list(line = l,color = 'rgb(255,255,255)')) %>%
  
  colorbar(show = F, title = 'Share of population',legend = list(x = 100, y = 0.5),legend = list(orientation = 'h')) %>%
  layout(
    title = 'Share of population per country trapped in multi level poverty',
    geo = g )
k
```


### Plotting the Gini indices

Below is the code for plotting the Gini indices for the eight countries with the lowest Gini index according to the data from the world map. The Gini index is a measure for how wealth is distributed in a certain country. The higher the Gini index, the more unequal the wealth is distributed. The theoretical maximum value is nearly 100, where all the wealth is with less than one percent of the population. If the Gini index is 0, it represents complete equality in wealth distribution, so that everyone has the same wealth. In general wealth is measured in income.

```{r}
#CODE FOR THE GINI INDICES
# subset the data - selected var GINI
indicator_datagini = subset(indicator_data,indicator_data$Indicator.Code=="SI.POV.GINI")

# LINE PLOT FOR THE COUNTRIES WITH THE HIGHEST GINI INDEXES
# extract the right years (25:60 is 1980 till 2015)
id = indicator_datagini[,c(1:3,4:4, 25:60)]
# remove the 'X' in the columns
colnames(id) <- sub("X", "", colnames(id))
# change the format
idm = melt(id, id=c("Country.Name", "Indicator.Code","Indicator.Name","Country.Code"), value.name = "Year")
# throw away the rows with missing data
idm <- na.omit(idm, cols="value")
```

From the graph we can conclude that the Gini indices for the seven plotted countries in general oscillates between 35 and 65. We can also see that for the most countries there is not a lot of progression over the last 35 years. For example, Madagascar had a Gini index of 46,8 in 1980 and has a Gini index of 42,6 in 2012, while in the years in between the Gini index went up and down several times.

```{r}
#What countries have the lowest gini indices?
cl <- c("MDG","BDI","MWI","GNB","MOZ","ZMB","LSO")
# subset with only those countries
idmc <- subset(idm,idm$Country.Code %in% cl)
# plot the gini idexes of those countries over time
x <- list( title = "Years" )
y <- list( title = "Gini Index" )
m <- list(l=150, r=20, b=70, t=10)
pline <- plot_ly(idmc, x = ~idmc$variable, y = ~idmc$value, color = ~idmc$Country.Name) %>%
  add_lines(line = list(shape = "spline"))  %>% layout( title = 'Gini indexes for poorest countries',xaxis = x, yaxis = y, margin=m)
pline
```

### Plotting the Lorenz curve

Below is the code for the Lorenz curve of the country with the lowest Gini Index. The Lorenz curve shows the distribution of wealth between the people in a country. Every Lorenzcurve has its own Gini index. The more away the Lorenz curve is from the middle diagonal, the higher the Gini index and the more unfair the wealth is distributed. We can see for example in Lesotho that around 70% of the wealth is with only 40% of the people. We can conclude that in the countries with a high prevalence of poverty there is also a high Gini index. This means that for the poor people in those countries the conditions are even more extreme.

```{r}
# PLOT THE LORENZ CURVE OF ONE OF THE COUNTRIES (if a flat line occurs, there is no data)
# Get the indicators for the lorenz curve
my_var = c( "SI.DST.05TH.20","SI.DST.02ND.20","SI.DST.03RD.20", "SI.DST.04TH.20", "SI.DST.FRST.20")
# fill in country code in V1 and run code below
V1 = c("LSO")
# subset the data with only the country and the needed indicators
country_data = subset(indicator_data,indicator_data$Country.Code %in% V1)
COUNTRY_LC_V1 = subset(country_data,country_data$Indicator.Code %in% my_var)
# slice the needed data for the desirable year
COUNTRY_2015 = COUNTRY_LC_V1[,c(1:4,55:55)]
# create a vector for the lorenz curve function
p20 = c(0, 20, 40, 60 , 80,100)
# sort the values of the indicators. Make sure the year is the right one
d20 = sort(COUNTRY_2015$X2010)
# plot the lorenz curve
Lc.c <- Lc(d20, p20)
plot(Lc.c,col="darkred",lwd = 6, main = 'Lorenz Curve for Lesotho in the year 2010',xlab = 'Percentage of the people', ylab = 'percentage of the wealth')

gini_index_country = Gini(d20)

```


## Indicators for the model and their relation

Poverty has a strong relation with various outcomes of the society of a country. Therefore, we have explored the data to find variables that are correlated with the prevalence of poverty, and we have plotted them in bubble graphs. These variables shall also be used in our predictive model.

### Poverty and child mortality

Below is the code for the bubble between poverty and spending on education. In the graph we can see the relation between poverty and the child mortality under five years old within a country. The size of bubbles represents the percentage of people living in extreme poverty, to highlight that indicator. We can see that there is a positive relation between child mortality and poverty. This means that a country with a high percentage of people living in poverty also have a higher mortality rate of children under the age of five. 

```{r}
#determine size per bubble
slope <- 2.8e-6
df_bubble$size <- sqrt(df_bubble$Poverty * slope)*5000
colors = c('#FF934F','#FFD166','#5FCC8C','#EF6464','#5DCBEF','#8C6ACC','#CC6AAC')

p <- plot_ly(df_bubble, x = ~ChildMort, y = ~Poverty, color = ~Region, size = ~size, colors = colors,
             type = 'scatter', mode = 'markers', sizes = c(min(df_bubble$size), max(df_bubble$size)),
             marker = list(symbol = 'circle', sizemode = 'diameter',
                           line = list(width = 2, color = '#FFFFFF')),
             text = ~paste('Country:', Country.Name,
                           '<br> Region:', Region,
                           '<br> Childmortality under 5 per 1000 births: ', ChildMort,"%",
                           "<br> Percentage of population living in Extreme Poverty: ", Poverty,"%",
                           "<br> Total population living in Extreme Poverty:", TotalPopPov,"M",
                           '<br> Total population:', TotalPop, "M")) %>%
  layout(title = 'Childmortality and the prevalence of Extreme Poverty',
         xaxis = list(title = 'Childmortality under 5 per 1000 births',
                      gridcolor = 'rgb(255, 255, 255)',
                      zerolinewidth = 1,
                      ticklen = 4,
                      gridwidth = 2),
         yaxis = list(title = 'Prevalence of Poverty (%population)',
                      gridcolor = 'rgb(255, 255, 255)',
                      zerolinewidth = 1,
                      ticklen = 5,
                      gridwith = 2),
         paper_bgcolor = 'rgb(243, 243, 243)',
         plot_bgcolor = 'rgb(243, 243, 243)')
p
```

### Poverty correlates with health outcomes

Moreover, people who live in extreme poverty also have particularly bad health outcomes. Countries with a low life expectancy (by birth), generally have a high prevalence of extreme poverty. As we can see, there is a clear negative relationship: people tend to live longer in countries where poverty is less common. The bubbles are relative for the extreme poverty headcount. Yet the correlation is far from perfect. Some countries such as Madagascar and Congo have a similar poverty headcount but a very different life expectancy. The highest difference is between the countries Guinea and Iceland with a difference of (82,92 - 57,78 =) 25 years.

```{r}
#determine size per bubble
slope <- 2.8e-6
df_bubble$size <- sqrt(df_bubble$Poverty * slope)*5000
colors = c('#FF934F','#FFD166','#5FCC8C','#EF6464','#5DCBEF','#8C6ACC','#CC6AAC')
                                            
p <- plot_ly(df_bubble, x = ~LifeExpec, y = ~Poverty, color = ~Region, size = ~size, colors = colors,
             type = 'scatter', mode = 'markers', sizes = c(min(df_bubble$size), max(df_bubble$size)),
             marker = list(symbol = 'circle', sizemode = 'diameter',
                           line = list(width = 2, color = '#FFFFFF')),
             text = ~paste('Country:', Country.Name, '<br> Life expectance by birth', LifeExpec,"years", '<br>Region:', Region,
                           "<br> Percentage of population living in Extreme Poverty", Poverty,"%",
                           "<br> Total population living in Extreme Poverty:", TotalPopPov,"M",
                           '<br> Total population:', TotalPop, "M")) %>%
  layout(title = 'Life Expectancy and Extreme Poverty 2013',
         xaxis = list(title = 'Life expectancy in years (by birth)',
                      gridcolor = 'rgb(255, 255, 255)',
                      zerolinewidth = 1,
                      type = 'log',
                      ticklen = 4,
                      gridwidth = 2),
         yaxis = list(title = 'Prevalence of Poverty (% of population)',
                      gridcolor = 'rgb(255, 255, 255)',
                      zerolinewidth = 1,
                      ticklen = 5,
                      range = c(-15,100),
                      gridwith = 2),
         paper_bgcolor = 'rgb(243, 243, 243)',
         plot_bgcolor = 'rgb(243, 243, 243)')
p

```

# Model drafting, calibration and implementation 

Within this chatper, we will select our indicators for the predictive model, see section 4.1. Within section 4.2 we explain the model structure, the data used and the process of estimating the distrubtions for our priors. Within 4.3, we explain our data preparation. See section 4.4, for the implementation of our bayesian MCMC model in RJAGS. Within section 4.4, we calibrate our model based on historic data. See section 4.5 for our model output, predicting the poverty headcount based on our indicators. 

## Selected indicators

From section 3.3, we can observe a correlation between poverty and the prevalence of undernourishment, infant mortality and life expectancy. This indicates that these variables could be used in our predictive MCMC model. To test of the correlation is significant, we explored the correlation between the variables using the “PerformanceAnalytics” library, which has numerous options to calculate and display correlations between variables.

```{r}
var_correlation = c("SI.POV.DDAY","SP.DYN.LE00.IN","SN.ITK.DEFC.ZS","SH.DYN.MORT")

#subset the data with only the world and the two indicators above about population and people in poverty in %
df_correlation = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_correlation)
df_correlation = subset(df_correlation, select = c("Indicator.Code", "Country.Code", "Year", "Value"))
df_correlation = dcast(df_correlation,Country.Code + Year ~ Indicator.Code, value.var ="Value")
df_correlation = subset(df_correlation, df_correlation$Year==2012)
df_correlation = na.omit(df_correlation)
df_correlation = df_correlation[,c(3:6)]

cor_table <- cor(df_correlation, method = "pearson")
cor_table = round(cor_table,2)
suppressWarnings(chart.Correlation(df_correlation, histogram=TRUE, pch=19))

```

Using this library for the four indicators, the correlation has been calculated. In the plot, the distribution of each variable is shown on the diagonal. On the bottom of the diagonal, the bivariate scatter plots with a fitted line are displayed. On the top of the diagonal, the value of the correlation plus the significance level as stars. Each significance level is associated to a symbol: p-values(0, 0.001:***, 0.01:**, 0.05*). As we can see from the graphs and the p-values, all correlations between the variables are significant. This indicates that these variables could potentially be used as predictors within our model.
 
## Model structure

Many causal models can be drafted given the data of our indicators. One causal model is given in figure X below. The model consists of the three indicators mentioned earlier in section 3.3 and section 4.1. Within this, our model will consist off the dependent variable, poverty headcount below $1.90 and undernourishment, life expectancy and undernourishment as independent variables. From our causal model, we can derive a collider structure. We will pick this structure as the main structure of our MCMC model. Within the figure, the correlation statistics of the used predictors are within the figure.  We model a positive relation between the variables undernourishment and infant mortality and poverty. We expect a negative relation between life expectancy and poverty, thus in high poverty countries the life expectancy will be lower.  

```{r}

img1_path <- "Drawing1.png"
img1 <- readPNG(img1_path, native = TRUE, info = TRUE)
attr(img1, "info")

include_graphics(img1_path)
```
 
### Beta distributions

In statistics, Bayesian linear regression is used as an approach to linear regression in which the analysis is undertaken in the context of Bayesian inference (Kruske). For a Bayesian regression, the form of the prior distribution need to be estimated. Therefore, we need to estimate the distribution of our three indicators.

For our estimate of the distribution of our priors, we used library library(MASS) and library(fitdistrplus). They offer a range of function to plot histograms, estimate distributions and plot them into the histogram. See below for our approach for every individual indicator.

```{r echo=FALSE}
#DUPLICATED THIS CODE TO RUN OUR FITTING GRAPHS FOR BETA's

############################################################
#selecting data from wdi
var_predictors = c("SP.DYN.LE00.IN","SN.ITK.DEFC.ZS","SH.DYN.MORT")

#subset the data with the three predicters
df_predictors = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_predictors)
df_predictors = subset(df_predictors, select = c("Indicator.Code","Region","Country.Name", "Country.Code", "Year", "Value"))
df_predictors = dcast(df_predictors,Country.Code + Region + Country.Name + Year ~ Indicator.Code, value.var ="Value")
df_predictors = subset(df_predictors, df_predictors$Year==2015)
df_predictors = df_predictors[-which(rowSums(is.na(df_predictors))> 0),]
df_predictors = subset(df_predictors, df_predictors$Country.Code %in% all_countries$Country.Code)

#is the script Average poverty 2010 - 2015
#selecting data from wdi + average of 6 years 2010 - 2015 -----------
year = c('2010','2011', '2012','2013','2014','2015')
poverty_average = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% "SI.POV.DDAY")
poverty_average = subset(poverty_average,poverty_average$Year %in% year)
poverty_average = subset(poverty_average, select = c("Indicator.Code","Country.Name", "Country.Code", "Year", "Value"))
#Calculate average over columns
poverty_average = dcast(poverty_average,Country.Code + Country.Name + Indicator.Code ~ Year, value.var ="Value")
poverty_average['Mean'] = rowMeans(poverty_average[,4:9],na.rm = T)
poverty_average = poverty_average[,c(1:2,10:10)]
#dropping zero's and NA's
poverty_average = na.omit(poverty_average)
poverty_average = poverty_average[apply(poverty_average!=0, 1, all),]
### ------------------------------------------------------------------

#combine the poverty dataframe with the predictors dataframe
poverty_JAGS = subset(poverty_average,poverty_average$Country.Code %in% df_predictors$Country.Code)
predictors_JAGS = subset(df_predictors,df_predictors$Country.Code %in% poverty_average$Country.Code)
df_jags_year = cbind(predictors_JAGS,poverty_JAGS$Mean)

#Select the predictors and the predicted value from the dataframe
poverty = df_jags_year$`poverty_JAGS$Mean`
life_expacteny = df_jags_year$SP.DYN.LE00.IN
undernourishment = df_jags_year$SN.ITK.DEFC.ZS
child_mortality = df_jags_year$SH.DYN.MORT
n = nrow(df_jags_year)

#standardize the values
y <- poverty
x1 <- undernourishment
x2 <- child_mortality
x3 <- life_expacteny
y  <- (y-mean(y))/sd(y)
x1 <- (x1-mean(x1))/sd(x1)
x2 <- (x2-mean(x2))/sd(x2)
x3 <- (x3-mean(x3))/sd(x3)
############################################################

```

### Undernourishment

In the figure below, a histogram of the undernourishment have been given. The histogram indicates an exponential distribution. When we fit this distribution using fitdistr (from the imported library) and plot this back in to the histogram, the red line is being created showing the shape of the real data. We see that especially that the high amount countries with a rather low undernourishment is not that well represented within the fitted distribution. For the higher values of undernourishment within our data, the fitted distribution actually follows the observed data rather well, thus accepting the fitted data for our beta2 distribution. 

```{r}
fit1 <- fitdistr(df_jags_year$SN.ITK.DEFC.ZS, densfun="exponential")  # we assume my_data ~ Normal(?,?)
hist(df_jags_year$SN.ITK.DEFC.ZS, pch=20, breaks=15, prob=TRUE, main="")
curve(dexp(x,0.082936680,log = FALSE), col="red", lwd=2, add=T)

```

### Child mortality

In the figure below, a histogram of the child mortality have been plotted. The histogram once again indicates an exponential distribution. When we try to fit this distribution, we end up with a distribution represented by the red line, see the figure below.

```{r}
fit3 <- fitdistr(df_jags_year$SH.DYN.MORT, densfun="exponential")  # we assume my_data ~ Normal(?,?)
hist(df_jags_year$SH.DYN.MORT, pch=20, breaks=15, prob=TRUE, main="")
curve(dexp(x,0.031210986,log = FALSE), col="red", lwd=2, add=T)
```

### Life expectancy

In the figure below, a histogram of the life expectancy have been given. The histogram indicates an skew normal distribution or Weibull distribution.  When we try to fit a Weibull curve, we estimate the following distribution, see the red line in the graph. We see that especially that the high density of countries with a high life expectancy is not that well represented within the fitted distribution. But for the total range, this Weibull distribution follows the provided data well, thus also accepting this distribution for our prior beta4. 

```{r}
fit2 <- fitdistr(df_jags_year$SP.DYN.LE00.IN, densfun="Weibull")  # we assume my_data ~ Normal(?,?)
hist(df_jags_year$SP.DYN.LE00.IN, pch=20, breaks=15, prob=TRUE, main="")
curve(dweibull(x,14.74,74.7498634,log = FALSE), col="red", lwd=2, add=T)
```

## Data preparation

To run the jags model a dataframe has been created with the four indicators: poverty, infant mortality, undernourishment and life expectancy. This dataframe may not contain NA-values. In order to get a dataframe first a dataset for the predictors have been created for the year 2015. Without the NA-values it contains data for 160 countries. Because of the lack of data on the share of the population living under the extreme poverty line ($1.90 a day). When we had used the poverty data from 2015 we could have a dataset containing only 20 countries. The dataset is made which contains the average share of a country between 2011-2015. This dataset contains the mean on the extreme poverty line for 138 countries. 

For the JAGS model these two datasets have been merged. This merged dataset, after omitting the NA-values, contains information for 113 countries. The indicators present in the dataset have to be standardized values in order to compare them in the model. Values can be standardized using the following function: y = (y-mean(y)) / standard deviation(y). Now the values are standardized we’re able to run a JAGS model with this dataset. 


```{r}

#selecting data from wdi
var_predictors = c("SP.DYN.LE00.IN","SN.ITK.DEFC.ZS","SH.DYN.MORT")

#subset the data with the three predicters
df_predictors = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% var_predictors)
df_predictors = subset(df_predictors, select = c("Indicator.Code","Region","Country.Name", "Country.Code", "Year", "Value"))
df_predictors = dcast(df_predictors,Country.Code + Region + Country.Name + Year ~ Indicator.Code, value.var ="Value")
df_predictors = subset(df_predictors, df_predictors$Year==2015)
df_predictors = df_predictors[-which(rowSums(is.na(df_predictors))> 0),]
df_predictors = subset(df_predictors, df_predictors$Country.Code %in% all_countries$Country.Code)

#is the script Average poverty 2010 - 2015
#selecting data from wdi + average of 6 years 2010 - 2015 -----------
year = c('2010','2011', '2012','2013','2014','2015')
poverty_average = subset(our_indicator_data,our_indicator_data$'Indicator.Code' %in% "SI.POV.DDAY")
poverty_average = subset(poverty_average,poverty_average$Year %in% year)
poverty_average = subset(poverty_average, select = c("Indicator.Code","Country.Name", "Country.Code", "Year", "Value"))
#Calculate average over columns
poverty_average = dcast(poverty_average,Country.Code + Country.Name + Indicator.Code ~ Year, value.var ="Value")
poverty_average['Mean'] = rowMeans(poverty_average[,4:9],na.rm = T)
poverty_average = poverty_average[,c(1:2,10:10)]
#dropping zero's and NA's
poverty_average = na.omit(poverty_average)
poverty_average = poverty_average[apply(poverty_average!=0, 1, all),]
### ------------------------------------------------------------------

#combine the poverty dataframe with the predictors dataframe
poverty_JAGS = subset(poverty_average,poverty_average$Country.Code %in% df_predictors$Country.Code)
predictors_JAGS = subset(df_predictors,df_predictors$Country.Code %in% poverty_average$Country.Code)
df_jags_year = cbind(predictors_JAGS,poverty_JAGS$Mean)

#Select the predictors and the predicted value from the dataframe
poverty = df_jags_year$`poverty_JAGS$Mean`
life_expacteny = df_jags_year$SP.DYN.LE00.IN
undernourishment = df_jags_year$SN.ITK.DEFC.ZS
child_mortality = df_jags_year$SH.DYN.MORT
n = nrow(df_jags_year)

#standardize the values
y <- poverty
x1 <- undernourishment
x2 <- child_mortality
x3 <- life_expacteny
y  <- (y-mean(y))/sd(y)
x1 <- (x1-mean(x1))/sd(x1)
x2 <- (x2-mean(x2))/sd(x2)
x3 <- (x3-mean(x3))/sd(x3)

```

## Model implementation in RJAGS

The JAGS model is based on the collider model provided in the course TPM-EPA1315. The causal model is specified in the likelihood functions. The prior for the beta’s is set with the distributions given in 4.2.1. For beta1 a normal distribution is used, because no distribution can be predicted for this beta. The prior of the variance uses a uniform distribution between 0 and 0.1 as has been provided in the JAGS model. For the variance, we consider that no prior knowledge is available about the distribution of the variance of the indicators in our model. In order get a certain range of the predicted values we have chosen for this uniform distribution. The JAGS model implemented in R can be seen below.

```{r}
#Our model
model_string <- "model{

# Likelihood
for(i in 1:n){
y[i]  ~ dnorm(mu[i],inv.var1)
mu[i] <- beta1 + beta2*x1[i] + beta3*x2[i] + beta4*x3[i]
}

# Prior for beta
beta1 ~ dexp(0.072029)
beta2 ~ dexp(0.082930)       #undernourishment
beta3 ~ dexp(0.032092)       #child mortality
beta4 ~ dweib(14,74.74)      #life expactency

# Prior for the inverse variance
var1       ~   dunif(0,0.1)  #poverty
inv.var1   <-  1/var1
sigma1     <-  sqrt(var1)
}"
```

## Model calibration

In section 4.4, we have set up our input data for the bayesian model using MCMC. Now it is time to calibrate our parameters so that we can use our predictive model to estimate the poverty for different years based on our indicator data. We calibrate our model using the average over 6 years. The use of aggregated data is a limitation of this research, but we are forced to do this because of the missing data.

```{r}
model <- jags.model(textConnection(model_string), data = list(y=y, x1=x1,x2=x2,x3=x3,n=n),n.chains = 4)

update(model, 10000, progress.bar="none"); # Burn-in for 10000 samples

samp <- coda.samples(model, 
                     variable.names=c("beta1","beta2","beta3","beta4","sigma1"), 
                     n.iter=20000, progress.bar="text")

saveRDS(samp,"modelrun.rds")
```
We ran the model, using the data input and distributions, while using a burn-in period of 10000 samples. In the ACF plot below, strong autocorrelations can be seen. All trace plots cover the same space. The parameter mix well through the parameter spaces and the beginning and ends look the same. This all indicates that we have estimate reasonably parameters. Our Gelman plots indicates that there is more variance between the chains then there is within. But the statistics are near one and are converged. The Gelman plot can be improved when the variance between the chains is smaller then the variance within the chains. 

The density plots below, show different outputs. For beta-1 and sigma-1 the density plot shows that there are very different densities by chain. While if you look at the density plots of the other beta’s the densities are the same regardless of the chain. It shows us that we have a good distribution chosen for our estimated beta’s. Due to complexity reason, ror beta1 and sigma1 we have not specified a specific distribution. The negatively affects our output which can be seen in the corresponding density plot of sigma-1 and beta-1.

```{r}
#summary + plots
summary(samp)
traceplot(samp)
par(mar=c(.4,.4,.4,.4))
gelman.plot(samp)
densplot(samp)
acfplot(samp)
effectiveSize(samp)

sampmatrix = as.matrix(samp)
# take the first four parameters, but drop off the noise!
param <-sampmatrix[sample(nrow(sampmatrix),size = 100, replace=FALSE),1:4]
# create a design matrix
n <- nrow(df_jags_year)
# make an intercept
intercept <- rep(1,n)
# bind your data together in the order used for modelling
data <- cbind(intercept,x1,x2,x3)
pred <- param %*% t(data)
pred <- t(pred)
# replicate the results
act <- rep(y,100)
par(mar=c(1,1,1,1))
plot(act,pred,xlab="Actual",ylab="Predicted")
```

## Model Summary

Our model summary output graph can be seen above. For all the beta’s and sigma-1 the mean, standard deviation and standard errors are given. As well as quantiles for each variables. The quantiles show us that the infant mortality is a very good predictor. Also the other predictors chosen predict really good, but less than infant mortality. Furthermore, the variance of our model is relatively low (around 0.3). 

Now the model summary has been explained, we’re interested in how the model is predicting. The plot above shows us the actual values compared to the predicted values. There can be seen that the model is predicting quite well until values within two standard deviations. For values higher then two standard deviations, the model is not predicting quite accurate. Generally, higher values for poverty are estimated 1-1.5 sd’s to low. This is probably because of the mismatch between the real data on poverty and the estimated beta1 and sigma1 for the predicted value of poverty, as discussed in section 4.5.1.

## Model results 

We can conclude our model is predicting rather well. Our model is usable to predict the value of poverty for all the countries where the data for this indicators is provided by the World Bank dataset. As explained before, 160 countries do meet this requirement. To use the indicator dataset, we standardise the values first, thereafter we use the model output to predict the values for poverty. The output gives us a standardised value. By using the mean and standard deviation of poverty we get the actual predicted values for poverty.

## Using the model - predicting poverty

We used our calibrated parameters from section 4.4 and 4.5 to estimate the poverty headcount for all countries with data available for the three independent variables. For a total of 160 countries, data is available for these countries. When we execute the predictive model, we get some very reasonable output, see the world map below.

Within dataframe predicted poverty, the model stores the output of the model. When we look at the recalculated values from the standardized output, we see that especially African and Asian countries get relative high predicted poverty headcounts. As earlier seen in our model calibration section, predicted values for high poverty countries are estimated rather low compared to the actual share of extreme poverty in those countries. 

```{r}
###---- Predicting ----------------------------------------------------------
sampmatrix = as.matrix(samp)
# take the first four parameters, but drop off the noise!
param <-sampmatrix[sample(nrow(sampmatrix),size = 100, replace=FALSE),1:4]
# create a design matrix
n <- nrow(df_jags_year)
# make an intercept
intercept <- rep(1,n)
# bind your data together in the order used for modelling
data <- cbind(intercept,x1,x2,x3)
pred <- param %*% t(data)
pred <- t(pred)
# replicate the results
act <- rep(y,100)
par(mar=c(1,1,1,1))
plot(act,pred,xlab="Actual",ylab="Predicted")

### ----- Filling in the NA -------------------------------------------------
#creates list with countries which have NA value on poverty
life_expactency2 = df_predictors$SP.DYN.LE00.IN
undernourishment2 = df_predictors$SN.ITK.DEFC.ZS
child_mortality2 = df_predictors$SH.DYN.MORT
n2 <- nrow(df_predictors)

#standardize these values
x21 <- life_expactency2
x22 <- undernourishment2
x23 <- child_mortality2
x21 <- (x21-mean(x21))/sd(x21)
x22 <- (x22-mean(x22))/sd(x22)
x23 <- (x23-mean(x23))/sd(x23)

# make an intercept
intercept2 <- rep(1,n2)
#predict the values for all the countries within the df_predictors dataset
data2 <- cbind(intercept2,x21,x22,x23)
pred2 <- param %*% t(data2)
pred2 <- t(pred2)
predicted = rowMeans(pred2[,0:100],na.rm = T)

predicted_poverty <- data.frame(
  c1 = df_predictors$Country.Code,
  c2 = df_predictors$Country.Name,
  c3 = predicted
)
names(predicted_poverty) <- c("Country.Code","Country.Name","score")

predicted_poverty$poverty = (predicted_poverty$score * sd(poverty)) + mean(poverty)

```

When we plot the calculated real poverty values inside a wordmap, we get the figure below. For the Western European countries and North America, the model estimate the share of total population living in extreme poverty rather high, due to the large range of uncertainty in our model. Across the board, we see that for countries that do have high poverty rates recorded in historic data, the model rather well predicts a high poverty rate for those countries. For example countries like the Central Africa Republic and Madagascar have high predicted poverty rates. These kind of results are satisfying. We can conclude that the constructed bayesian model can predict poverty to some extent, while taking into consideration the large range of uncertainty that is embedded in our MCMC model. 

```{r, layout="l-screen-inset", , fig.width=13, fig.height=8}
# light grey boundaries
l <- list(color = toRGB("grey"), width = 0.5)

predicted_poverty$hover <- with(predicted_poverty, paste
                              ( "Predicted year: 2015",'<br>',
                                "Predicited share under extreme poverty line:",poverty,"%" ,'<br>',
                                "Country:", Country.Name))

# specify map projection/options
g <- list(
  showframe = F,
  resolution = 5,
  showcoastlines = T,
  countrycolor = toRGB("grey"),
  coastlinecolor = toRGB("grey"),
  projection = list(type = 'Mercator'))

k <- plot_geo(predicted_poverty) %>%
  add_trace(z = ~poverty,text = ~hover, color = ~poverty, colors= 'Reds', 
            locations = ~Country.Code, 
            marker = list(line = l,color = 'rgb(255,255,255)')) %>%
  
  colorbar(title = 'Predicted share') %>%
  layout(title = 'Predicted prevelance of extreme poverty for 2015, based on model',geo = g)
k
```

# Evaluation

Insights gained from the figures and graphs is useful because they play an important role in assissting policy makers and project implementers by revealing the poverty trend in the world, the potential causes of poverty, and thus helping evaluating the efforts put in targeting poverty alleviation.

The objectives of this report are: (1) to explore the spatial and temporal distribution of poverty and inequality at the regional and national level, (2) to show the strong correlation between children mortality, health outcomes and poverty, (3) to estimate how the level of poverty will be reduced or boosted  based on data in education, mortality at national level.

## Insufficiency of model

In our model, due to the limitation of the quality and the quantity of data, the model has certain level of insufficiency. First, we could only use the indicators which satisfy the two following standards: it has relatively more “complete” data than the within the time period of 1990-2015, and it must have certain level correlation with poverty, which limits our choice on predictors in the Bayesian regression model. Second, our parameter setting of beta1 and sigma1 also has inaccuracy. The distribution model of our priors do not completely obey the uniform distribution or Weibull distribution, but still we assume they do, which contributes to potential inaccuracy in the estimated poverty data.

## How would we communicate our findings to decision makers?

According to the world map that we made, we show the spatial distribution of the people suffering from the poverty and the countries in two aspects: people living under extreme poverty line and the countries trapped in the multi level poverty. These graphs could help revealing where the poverty locates and make it more accurate when providing the assistance to alleviate the poverty. And also with the regression model we could estimate the poverty trend by data related to health conditions of the people.


#### Resources 

[1] https://www.globalgoals.org/1-no-poverty
[2] https://sdgcompass.org/sdgs/sdg-1
[3] https://ourworldindata.org/extreme-poverty
[4] http://pubdocs.worldbank.org/en/109701443800596288/PRN03Oct2015TwinGoals.pdf
[5] https://opendatawatch.com/blog/ending-poverty-needs-better-data/
[6] http://ieg.worldbankgroup.org/sites/default/files/Data/reports/poverty_focus_cp_1.pdf
[7] 7https://qz.com/africa/1428639/world-banks-measure-of-poverty-is-flawed/
[8] https://ourworldindata.org/extreme-poverty#correlates-determinants-and-consequences
[9] http://www.un.org/en/sections/issues-depth/big-data-sustainable-development/index.html
